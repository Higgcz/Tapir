//
//  TSLCar.m
//  Tapir
//
//  Created by Vojtech Micka on 26.04.14.
//  Copyright (c) 2014 Vojtech Micka. All rights reserved.
//

#import "TSLDriverAgent.h"
#import "TSLCar.h"
#import "TSLBody.h"
#import "TSLPlan.h"
#import "TSLPath.h"
#import "TSLIntersection.h"

#import "Vectors.h"

#import "../TGL/TGL.h"

@interface TSLDriverAgent ()

- (BOOL) shouldSpeedUp;

@end

@implementation TSLDriverAgent {
    BOOL _go;
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (instancetype) init
////////////////////////////////////////////////////////////////////////////////////////////////
{
    self = [super init];
    if (self) {
        [self setup];
    }
    return self;
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) setup
////////////////////////////////////////////////////////////////////////////////////////////////
{
    self.plan = [TSLPlan plan];
    
    // Prefered distance
    self.preferedDistance    = 5.0f;
    self.preferedDistanceMin = 1.0f;
    self.preferedDistanceMax = 10.0f;
}

#pragma mark - Car controling on Path

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) car:(TSLCar *) car arrivedToRoadObject:(TSLRoadObject *) roadObject
////////////////////////////////////////////////////////////////////////////////////////////////
{
    TSLPath *newPath;
    
    if ([roadObject isKindOfClass:[TSLIntersection class]]) {
        TSLIntersection *inters = (TSLIntersection *) roadObject;
        newPath = [inters pathFromRoad:self.plan.current toRoad:self.plan.nextRoad];
    } else {
        if ([roadObject isKindOfClass:[TSLRoad class]]) {
            TSLRoad *road = (TSLRoad *) roadObject;
            newPath = [road pathForLine:car.roadLine andDirection:car.roadDirection];
        }
        
        [self.plan moveNext];
    }
    
    if (newPath != nil) {
        [newPath putCar:car];
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) didStartCar:(TSLCar *) car
////////////////////////////////////////////////////////////////////////////////////////////////
{
    self.active = YES;
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (BOOL) shouldExitCar:(TSLCar *) car
////////////////////////////////////////////////////////////////////////////////////////////////
{
    if (self.isActive == NO || self.plan.nextRoad == nil) {
        return NO;
    }
    return YES;
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) didExitCar:(TSLCar *) car
////////////////////////////////////////////////////////////////////////////////////////////////
{
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) updateWithTimeSinceLastUpdate:(CFTimeInterval) deltaTime
////////////////////////////////////////////////////////////////////////////////////////////////
{
    [super updateWithTimeSinceLastUpdate:deltaTime];
    
    if ( self.isActive == NO ) return;
    
    CGFloat distance = [self.car getDistanceToCarAfter];
    
//    if (distance != CGFLOAT_MAX) {
//        distance -= self.preferedDistance;
//    }
    CGFloat desiredSpeed = distance - self.preferedDistance;

    if (desiredSpeed <= 0) {
        desiredSpeed = 0;
    }
    
//    if (desiredSpeed <= 0) {
//        id other = [self.car getClosestObjectAfter];
//        
//        if ([other isKindOfClass:[TSLCar class]]) {
//            TSLCar *otherCar = other;
//            
//            CGFloat otherSpeed = otherCar.speed;
//            BOOL sameDir = NSVectorsEqual(self.car.direction, otherCar.direction);
//            
//            if (sameDir) {
//                if (otherSpeed == 0) {
//                    desiredSpeed = 0;
//                }
//            } else {
//                if (otherSpeed == 0 && distance > 0) {
//                    desiredSpeed = distance - self.preferedDistanceMin;
//                } else {
//                    desiredSpeed = 0;
//                }
//            }
//            
//        }
//    }
    
    if (desiredSpeed > self.car.maxSpeed) {
        if ([self shouldSpeedUp]) {
            [self.car speedUp];
        } else {
            [self.car slowDown];
        }
    } else {
        self.car.speed = desiredSpeed;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (BOOL) shouldSpeedUp
////////////////////////////////////////////////////////////////////////////////////////////////
{
    return (rand() % 100) < 70;
}


#pragma mark - Setters

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) setActive:(BOOL) active
////////////////////////////////////////////////////////////////////////////////////////////////
{
    [super setActive:active];
    self.car.active = active;
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) setCar:(TSLCar *) car
////////////////////////////////////////////////////////////////////////////////////////////////
{
    _car = car;
    if (_car.driver != self) {
        _car.driver = self;
    }
}

#pragma mark - TSLColisionDelegate

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) colidesWith:(TSLBody *) otherBody
////////////////////////////////////////////////////////////////////////////////////////////////
{
    
}

#pragma mark - TSLObject

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) didCreatedAtUniverse:(TSLUniverse *) universe
////////////////////////////////////////////////////////////////////////////////////////////////
{
    [super didCreatedAtUniverse:universe];
}

////////////////////////////////////////////////////////////////////////////////////////////////
- (void) didDeleted
////////////////////////////////////////////////////////////////////////////////////////////////
{
    [super didDeleted];
}

@end
